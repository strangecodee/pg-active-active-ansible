- name: Set peer host dynamically
  set_fact:
    peer_host: "{{ hostvars[groups['postgres'] | difference([inventory_hostname]) | first].ansible_host }}"

# ---------------- FDW BASE ----------------

- name: Ensure postgres_fdw extension
  shell: sudo -u postgres psql -d {{ db_name }} -c "CREATE EXTENSION IF NOT EXISTS postgres_fdw;"

- name: Ensure fdw schema exists
  shell: sudo -u postgres psql -d {{ db_name }} -c "CREATE SCHEMA IF NOT EXISTS fdw;"

- name: Ensure FDW server exists
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    DO $$
    BEGIN
      IF NOT EXISTS (SELECT 1 FROM pg_foreign_server WHERE srvname='peer_srv') THEN
        CREATE SERVER peer_srv
        FOREIGN DATA WRAPPER postgres_fdw
        OPTIONS (host '{{ peer_host }}', port '{{ pg_port }}', dbname '{{ db_name }}');
      END IF;
    END$$;
    SQL

- name: Ensure FDW user mapping for postgres
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    DO $$
    BEGIN
      IF NOT EXISTS (
        SELECT 1 FROM pg_user_mappings um
        JOIN pg_foreign_server s ON um.srvid=s.oid
        WHERE s.srvname='peer_srv'
          AND um.umuser=(SELECT oid FROM pg_roles WHERE rolname='postgres')
      ) THEN
        CREATE USER MAPPING FOR postgres
        SERVER peer_srv
        OPTIONS (user '{{ repl_user }}', password '{{ repl_password }}');
      END IF;
    END$$;
    SQL

- name: Ensure FDW user mapping for repluser
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    DO $$
    BEGIN
      IF NOT EXISTS (
        SELECT 1 FROM pg_user_mappings um
        JOIN pg_foreign_server s ON um.srvid=s.oid
        WHERE s.srvname='peer_srv'
          AND um.umuser=(SELECT oid FROM pg_roles WHERE rolname='{{ repl_user }}')
      ) THEN
        CREATE USER MAPPING FOR {{ repl_user }}
        SERVER peer_srv
        OPTIONS (user '{{ repl_user }}', password '{{ repl_password }}');
      END IF;
    END$$;
    SQL

- name: Import orders_test as foreign table into fdw schema
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    DO $$
    BEGIN
      IF NOT EXISTS (
        SELECT 1 FROM information_schema.foreign_tables
        WHERE foreign_table_schema='fdw'
          AND foreign_table_name='orders_test_peer'
      ) THEN
        IMPORT FOREIGN SCHEMA public
        LIMIT TO (orders_test)
        FROM SERVER peer_srv
        INTO fdw;
        ALTER FOREIGN TABLE fdw.orders_test RENAME TO orders_test_peer;
      END IF;
    END$$;
    SQL

# ---------------- NODE IDENTITY ----------------

- name: Create node identity functions
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    CREATE OR REPLACE FUNCTION public.local_node()
    RETURNS text LANGUAGE sql STABLE AS $$
      SELECT current_setting('app.node_role');
    $$;

    CREATE OR REPLACE FUNCTION public.owner_node(p_id bigint)
    RETURNS text LANGUAGE sql IMMUTABLE AS $$
      SELECT CASE WHEN p_id % 2 = 1 THEN 'ODD' ELSE 'EVEN' END;
    $$;
    SQL

# ---------------- SEQUENCE PARITY ----------------

- name: Enforce ODD sequence
  when: node_role == "ODD"
  shell: |
    sudo -u postgres psql -d {{ db_name }} -c "
    ALTER SEQUENCE orders_test_id_seq INCREMENT BY 2;
    SELECT setval('orders_test_id_seq', 1, false);
    "

- name: Enforce EVEN sequence
  when: node_role == "EVEN"
  shell: |
    sudo -u postgres psql -d {{ db_name }} -c "
    ALTER SEQUENCE orders_test_id_seq INCREMENT BY 2;
    SELECT setval('orders_test_id_seq', 2, false);
    "

# ---------------- INSERT OWNERSHIP ----------------

- name: Create insert guard
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    CREATE OR REPLACE FUNCTION public.orders_insert_guard()
    RETURNS trigger LANGUAGE plpgsql AS $$
    BEGIN
      IF current_setting('session_replication_role') = 'replica' THEN
        RETURN NEW;
      END IF;

      IF NEW.id IS NULL THEN
        NEW.id := nextval('orders_test_id_seq');
      END IF;

      IF public.local_node() <> public.owner_node(NEW.id) THEN
        RAISE EXCEPTION
          'Wrong node. ID % belongs to % node.',
          NEW.id, public.owner_node(NEW.id);
      END IF;

      NEW.node := public.local_node();
      RETURN NEW;
    END;
    $$;
    SQL

- name: Ensure insert trigger
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    DROP TRIGGER IF EXISTS trg_orders_insert ON orders_test;
    CREATE TRIGGER trg_orders_insert
    BEFORE INSERT ON orders_test
    FOR EACH ROW
    EXECUTE FUNCTION public.orders_insert_guard();
    SQL

# ---------------- UPDATE ROUTING ----------------

- name: Create update router
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    CREATE OR REPLACE FUNCTION public.orders_update_router()
    RETURNS trigger LANGUAGE plpgsql AS $$
    BEGIN
      IF current_setting('session_replication_role') = 'replica' THEN
        RETURN NEW;
      END IF;

      IF public.local_node() = public.owner_node(OLD.id) THEN
        RETURN NEW;
      END IF;

      UPDATE fdw.orders_test_peer
      SET item = NEW.item, qty = NEW.qty
      WHERE id = OLD.id;

      RETURN NULL;
    END;
    $$;
    SQL

- name: Ensure update trigger
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    DROP TRIGGER IF EXISTS trg_orders_update ON orders_test;
    CREATE TRIGGER trg_orders_update
    BEFORE UPDATE ON orders_test
    FOR EACH ROW
    EXECUTE FUNCTION public.orders_update_router();
    SQL

# ---------------- DELETE ROUTING ----------------

- name: Create delete router
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    CREATE OR REPLACE FUNCTION public.orders_delete_router()
    RETURNS trigger LANGUAGE plpgsql AS $$
    BEGIN
      IF current_setting('session_replication_role') = 'replica' THEN
        RETURN OLD;
      END IF;

      IF public.local_node() = public.owner_node(OLD.id) THEN
        RETURN OLD;
      END IF;

      DELETE FROM fdw.orders_test_peer WHERE id = OLD.id;
      RETURN NULL;
    END;
    $$;
    SQL

- name: Ensure delete trigger
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    DROP TRIGGER IF EXISTS trg_orders_delete ON orders_test;
    CREATE TRIGGER trg_orders_delete
    BEFORE DELETE ON orders_test
    FOR EACH ROW
    EXECUTE FUNCTION public.orders_delete_router();
    SQL

