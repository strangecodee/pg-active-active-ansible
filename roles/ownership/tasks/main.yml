- name: Set peer host dynamically
  set_fact:
    peer_host: "{{ hostvars[groups['postgres'] | difference([inventory_hostname]) | first].ansible_host }}"

# ------------------ FDW SETUP ------------------

- name: Ensure postgres_fdw extension exists
  shell: sudo -u postgres psql -d {{ db_name }} -c "CREATE EXTENSION IF NOT EXISTS postgres_fdw;"

- name: Ensure FDW server exists
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    DO $$
    BEGIN
      IF NOT EXISTS (SELECT 1 FROM pg_foreign_server WHERE srvname='peer_srv') THEN
        CREATE SERVER peer_srv
        FOREIGN DATA WRAPPER postgres_fdw
        OPTIONS (host '{{ peer_host }}', port '{{ pg_port }}', dbname '{{ db_name }}');
      END IF;
    END$$;
    SQL

- name: Ensure FDW user mapping exists
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    DO $$
    BEGIN
      IF NOT EXISTS (
        SELECT 1 FROM pg_user_mappings um
        JOIN pg_foreign_server s ON um.srvid=s.oid
        WHERE s.srvname='peer_srv'
          AND um.umuser=(SELECT oid FROM pg_roles WHERE rolname='{{ repl_user }}')
      ) THEN
        CREATE USER MAPPING FOR {{ repl_user }}
        SERVER peer_srv
        OPTIONS (user '{{ repl_user }}', password '{{ repl_password }}');
      END IF;
    END$$;
    SQL

- name: Ensure foreign table exists
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    DO $$
    BEGIN
      IF NOT EXISTS (
        SELECT 1 FROM information_schema.foreign_tables
        WHERE foreign_table_name='orders_test_peer'
      ) THEN
        IMPORT FOREIGN SCHEMA public
        LIMIT TO (orders_test)
        FROM SERVER peer_srv
        INTO public;
        ALTER FOREIGN TABLE orders_test RENAME TO orders_test_peer;
      END IF;
    END$$;
    SQL

# ------------------ NODE IDENTITY ------------------

- name: Create node identity functions
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    CREATE OR REPLACE FUNCTION local_node()
    RETURNS text LANGUAGE sql STABLE AS $$
      SELECT current_setting('app.node_role');
    $$;

    CREATE OR REPLACE FUNCTION owner_node(p_id bigint)
    RETURNS text LANGUAGE sql IMMUTABLE AS $$
      SELECT CASE WHEN p_id % 2 = 1 THEN 'ODD' ELSE 'EVEN' END;
    $$;
    SQL

# ------------------ SEQUENCE PARITY ------------------

- name: Enforce ODD sequence parity
  when: node_role == "ODD"
  shell: |
    sudo -u postgres psql -d {{ db_name }} -c "
    ALTER SEQUENCE orders_test_id_seq INCREMENT BY 2;
    SELECT setval('orders_test_id_seq', 1, false);
    "

- name: Enforce EVEN sequence parity
  when: node_role == "EVEN"
  shell: |
    sudo -u postgres psql -d {{ db_name }} -c "
    ALTER SEQUENCE orders_test_id_seq INCREMENT BY 2;
    SELECT setval('orders_test_id_seq', 2, false);
    "

# ------------------ INSERT OWNERSHIP ------------------

- name: Create insert guard function
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    CREATE OR REPLACE FUNCTION orders_insert_guard()
    RETURNS trigger LANGUAGE plpgsql AS $$
    BEGIN
      IF current_setting('session_replication_role') = 'replica' THEN
        RETURN NEW;
      END IF;

      IF NEW.id IS NULL THEN
        NEW.id := nextval('orders_test_id_seq');
      END IF;

      IF local_node() <> owner_node(NEW.id) THEN
        RAISE EXCEPTION
          'Wrong node. ID % belongs to % node.',
          NEW.id, owner_node(NEW.id);
      END IF;

      NEW.node := local_node();
      RETURN NEW;
    END;
    $$;
    SQL

- name: Ensure insert trigger
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    DROP TRIGGER IF EXISTS trg_orders_insert ON orders_test;
    CREATE TRIGGER trg_orders_insert
    BEFORE INSERT ON orders_test
    FOR EACH ROW
    EXECUTE FUNCTION orders_insert_guard();
    SQL

# ------------------ UPDATE ROUTING (FDW) ------------------

- name: Create update router function
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    CREATE OR REPLACE FUNCTION orders_update_router()
    RETURNS trigger LANGUAGE plpgsql AS $$
    BEGIN
      IF current_setting('session_replication_role') = 'replica' THEN
        RETURN NEW;
      END IF;

      IF local_node() = owner_node(OLD.id) THEN
        RETURN NEW;
      END IF;

      UPDATE orders_test_peer
      SET item = NEW.item, qty = NEW.qty
      WHERE id = OLD.id;

      RETURN NULL;
    END;
    $$;
    SQL

- name: Ensure update trigger
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    DROP TRIGGER IF EXISTS trg_orders_update ON orders_test;
    CREATE TRIGGER trg_orders_update
    BEFORE UPDATE ON orders_test
    FOR EACH ROW
    EXECUTE FUNCTION orders_update_router();
    SQL

# ------------------ DELETE ROUTING (FDW) ------------------

- name: Create delete router function
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    CREATE OR REPLACE FUNCTION orders_delete_router()
    RETURNS trigger LANGUAGE plpgsql AS $$
    BEGIN
      IF current_setting('session_replication_role') = 'replica' THEN
        RETURN OLD;
      END IF;

      IF local_node() = owner_node(OLD.id) THEN
        RETURN OLD;
      END IF;

      DELETE FROM orders_test_peer WHERE id = OLD.id;
      RETURN NULL;
    END;
    $$;
    SQL

- name: Ensure delete trigger
  shell: |
    sudo -u postgres psql -d {{ db_name }} <<'SQL'
    DROP TRIGGER IF EXISTS trg_orders_delete ON orders_test;
    CREATE TRIGGER trg_orders_delete
    BEFORE DELETE ON orders_test
    FOR EACH ROW
    EXECUTE FUNCTION orders_delete_router();
    SQL

- name: Debug
  debug:
    msg:
      - "Node = {{ node_role }}"
      - "DB = {{ db_name }}"
      - "Peer = {{ peer_host }}"
